<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<title>CPU Scheduler Visualizer</title>
		<style>
			body {
				font-family: "Segoe UI", sans-serif;
				text-align: center;
				background: #f5f5f5;
				padding: 2rem;
			}
			canvas {
				border: 1px solid #ccc;
				background: #fff;
				margin-top: 1rem;
			}
			button {
				margin: 0.5rem;
				padding: 0.5rem 1rem;
				font-size: 16px;
				cursor: pointer;
			}
		</style>
	</head>
	<body>
		<h1>CPU Scheduling Visualizer</h1>
		<button id="stepBtn">▶ Step</button>
		<button id="addBtn">➕ Add Process</button>
		<canvas id="cpuCanvas" width="1000" height="400"></canvas>

		<script>
			const canvas = document.getElementById("cpuCanvas");
			const ctx = canvas.getContext("2d");

			let time = 0;
			let pidCounter = 0;
			const pxUnit = 20;
			const cpu = { x: 450, y: 200, width: 100, height: 60 };
			let currentProcess = null;
			let processQueue = [];

			function randomBetween(min, max) {
				return Math.floor(Math.random() * (max - min + 1)) + min;
			}

			function createProcess() {
				const bt = randomBetween(1, 5);
				const at = time + randomBetween(0, 3);
				return {
					pid: pidCounter++,
					at,
					bt,
					remaining: bt,
					width: bt * pxUnit,
					x: 50 + processQueue.length * 120,
					y: 50,
					inCpu: false,
					done: false,
				};
			}

			function drawCPU() {
				ctx.fillStyle = "#ddd";
				ctx.fillRect(cpu.x, cpu.y, cpu.width, cpu.height);
				ctx.fillStyle = "#000";
				ctx.font = "18px monospace";
				ctx.fillText("CPU", cpu.x + 28, cpu.y + 36);
			}

			function drawProcesses() {
				for (const p of processQueue) {
					if (p.done) continue;

					ctx.fillStyle = p.inCpu ? "#2196F3" : "#4CAF50";
					ctx.fillRect(p.x, p.y, p.width, 40);

					ctx.fillStyle = "#fff";
					ctx.font = "14px sans-serif";
					ctx.fillText(`P${p.pid}`, p.x + p.width / 2 - 10, p.y + 25);
				}
			}

			function moveToCPU(proc) {
				proc.inCpu = true;
				proc.x = cpu.x + (cpu.width - proc.width) / 2;
				proc.y = cpu.y + 10;
			}

			function stepSimulation() {
				time++;

				// Check if current process is finished
				if (currentProcess && currentProcess.remaining <= 0) {
					currentProcess.done = true;
					currentProcess = null;
				}

				// If CPU is free, get next process
				if (!currentProcess) {
					currentProcess = processQueue.find((p) => !p.done && p.at <= time && !p.inCpu);
					if (currentProcess) {
						moveToCPU(currentProcess);
					}
				}

				// Process current task
				if (currentProcess) {
					currentProcess.remaining--;
					currentProcess.width = (currentProcess.remaining / currentProcess.bt) * (currentProcess.bt * pxUnit);
				}

				draw();
			}

			function draw() {
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				drawCPU();
				drawProcesses();

				// Time Display
				ctx.fillStyle = "#000";
				ctx.font = "18px monospace";
				ctx.fillText(`Time: ${time}`, 20, 30);
			}

			// Initial Process
			processQueue.push({
				pid: pidCounter++,
				at: 0,
				bt: 4,
				remaining: 4,
				width: 4 * pxUnit,
				x: 50,
				y: 50,
				inCpu: false,
				done: false,
			});

			draw();

			document.getElementById("stepBtn").addEventListener("click", stepSimulation);
			document.getElementById("addBtn").addEventListener("click", () => {
				processQueue.push(createProcess());
				draw();
			});
		</script>
	</body>
</html>
